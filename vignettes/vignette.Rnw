%\VignetteIndexEntry{GPrank User Guide}
%\VignetteKeywords{Gaussian process rank}
%\VignetteDepends{gptk}
%\VignettePackage{GPrank}
\documentclass[a4paper]{article}
\usepackage{url}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}
\usepackage{url}
\usepackage{Sweave}

\title{\Rpackage{GPrank} User Guide}
\author{Hande Topa and Antti Honkela}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}

\begin{document}
\maketitle

\tableofcontents

\section{Introduction}

The \Rpackage{GPrank} package has been built upon the \Rpackage{gptk}
(Gaussian process toolkit) package~\citep{Kalaitzis2011} with the
addition of ``fixed variance'' kernel which allows to incorporate
additional variance information from pre-processing of the
observations into the Gaussian process (GP) regression models.

GPs are an ideal model for short and irregularly sampled time
series and they can be used to model and rank multiple time series,
each generated by different items within an
experiment.

In~\citep{Topa2015} and~\citep{Topa2016}, we have
evaluated the performance of our GP-based ranking method by comparing
the precision and recall under different scenarios with and without
variance usage. Simulation results have shown that variance usage
leads to a higher average precision, which means less false positives
appearing in the top of the ranked list. Motivated by these results,
here we will explain how to use GPrank package and then provide
examples for two different applications we had in our papers.

\section{Citing \Rpackage{GPrank}}
\label{sec:cite}
To cite \Rpackage{GPrank} in publications, please cite relevant of the
two methodology papers~\citep{Topa2015,Topa2016} that the software is
based on.

\section{Methods overview} 
Our GP-based ranking method uses Bayes factors to rank muliple time series where the Bayes factors are computed for each item by the ratio of its marginal likelihood under two alternative GP models, namely time-dependent and time-independent. Time-independent model (which is referred as the \textit{null model} in the package) assumes no temporal dependency between observations and uses only a white noise kernel to model the noise. Time-dependent model (which is referred as the \textit{model} in the package) on the other hand, assumes a smooth temporal behavior, and in addition to the white noise kernel, it also includes a radial basis function (RBF) kernel to capture the temporal dependency. Furthermore, we use a fixed variance kernel in both models in order to incorporate variance information which could be obtained by appropriate estimation methods during pre-processing. For more technical details about the GP models, please refer to the papers mentioned in Section~\ref{sec:cite}.

\section{General usage of \Rpackage{GPrank}}
\subsection{Installing the package}

In order to install \Rpackage{GPrank} package from the GitHub
repository, start R and run the following command:
<<eval=FALSE>>=
devtools::install_github("PROBIC/GPrank")
@

In order to install from CRAN, simply use the following command:
<<eval=FALSE>>=
install.packages("GPrank")
@

To load the package, run:
<<>>=
library("GPrank")
@

\subsection{Necessary data}
In order to construct a GP model, three vectors must be provided for each item. These vectors are: 
\begin{itemize}
\item t: vector containing the input values, i.e., sampled time points.
\item y: vector containing the observed values at the corresponding time points in vector t.
\item v: vector containing the variances at the corresponding time points in vector t.
\end{itemize}
Once we have obtained these vectors, we can construct a GP model with \Rfunction{constructModel} function using different kernels such as ``rbf'', ``white'', and ``fixedvariance'': 
\textit{Example:}
<<>>=
t=seq(0,20,5)
y=sin(t)
v=0.01*runif(5)
kernelTypes=c('rbf','white','fixedvariance')
model=constructModel(t,y,v,kernelTypes)
@

Please make sure that the three vectors have the same length with each other. If the data is replicated, please remember to adjust the input vector accordingly. For example, if there are two replicates observed at $n$ time points from time $t_1$ to $t_n$, vector $t$ must be defined as: $t=[t_1, t_1, t_2, t_2, \ldots, t_n, t_n]$.

\subsection{Fitting the models}
\Rfunction{gpTest} function takes $t$, $y$, and $v$ vectors as input arguments and fits two alternative GP models to the data, and computes the log Bayes factors: 
<<>>=
test_result=gpTest(t,y,v,
nullModelKernelTypes=c("white","fixedvariance"),
modelKernelTypes=c("rbf","white","fixedvariance"))
null_model=test_result$nullModel
model=test_result$model
logBF=test_result$logBF
@

\subsection{Visualizing the models}
\label{data:generalusage}
In order to visualize the fitted GP model, one can use the \Rfunction{plotGP} function. One can also specify the color of the plot with the second argument. One can optionally specify the limits of the y axis as the third argument. This helps to adjust the plotting area when GP models of multiple items are displayed in a single figure. For example, y-axis limits can be determined by using \Rfunction{getYlimits} function in such cases. This function adjusts the plotting area between the minimum and maximum values of multiple models also taking into account two standard deviation confidence intervals.
In addition, a color palette containing the distinctive colors from \Rpackage{RColorBrewer} package can be obtained with the function \Rfunction{getColorVector}. The generated plot in Figure~\ref{fig:generalusage} displays $\pm 2$ standard deviations confidence region (estimated from the fitted model) around the fitted line and errorbars denoting $\pm 2$ standard deviations (provided from fixed variances) around the observations.
<<eval=FALSE, echo=TRUE>>=
color="lightpink" # color=getColorVector()[1]
ylimits=getYlimits(y,v) # optional argument, also default
plotGP(model, color, ylimits)
title(xlab="t", ylab="y")
@
\begin{figure}[h]
  \begin{center}
<<fig=TRUE, eval=TRUE, echo=FALSE>>=
color="lightpink" # color=getColorVector()[1]
ylimits=getYlimits(y,v)
plotGP(model, color, ylimits)
title(xlab="t", ylab="y")
@
\end{center}
\caption{Fitted GP model for the example in Section~\ref{data:generalusage}.}
\label{fig:generalusage}
\end{figure}

\subsection{Building SQLite database}

Once we have had all the results ready, and saved the figures in png
format, we can use \Robject{createDatabase} function to create a
database which can be used to view the results in the web browser with
the help of \Rpackage{tigreBrowser} package~\citep{Honkela2011}.
\Rpackage{tigreBrowser} can display the selected GP profiles on a web
browser enabling to rank them according to provided parameters, such
as Bayes factors and fold changes. In order to view database in the
browser, please remember to place other required tigreBrowser files in
the same folder with the database as well. Also modify the database
name accordingly in ``tigreBrowser.cfg''. For more information please
see: \url{https://github.com/PROBIC/tigreBrowser}.

<<eval=TRUE>>=
BF=c(3,10,2) # Bayes factors
FoldChange=c(0.5,3,5) # Fold changes
dbParams=list("BF"=BF,"Fold change"=FoldChange)
identifiers=c("geneA","geneB","geneC")
dbInfo=list(database_name="testdb","database_params"=dbParams,
"identifiers"=identifiers)
figuresPath="figures/" # directory where the figures are saved
multi=1 # multiple figures will be displayed for each item
createDatabase(dbInfo,figuresPath,multi)
@
Note: Please place all figures in a subdirectory and specify its path in \Robject{figuresPath}, name the figures starting with the name of their corresponding identifiers. If there are multiple figures to be displayed for each item, add the specific extension after an underscore and set \Robject{multi} to TRUE. For example: ``geneA\_gene.png'', ``geneA\_abstr.png'', ``geneA\_reltr.png''. If there is only a single figure for each item, name it with its identifier. For example: ``geneA.png''. 

\section{Applications}
\subsection{RNA-seq transcript expression analysis using BitSeq}
\subsubsection{Sample data}
For demonstrating the usage of the functions with examples, we will be using a small sample data from an RNA-seq time series experiment which was introduced in~\citep{Honkela2015}. The sample data set, named RNAseqDATA, contains mean and standard deviation information on the expression levels of 5 transcripts (which were originated from 2 genes) at 10 time points (0, 5, 10, 20, 40, 80, 160, 320, 640, 1280 mins) for three settings: ``gene'', ``abstr'' (absolute transcript), and ``reltr'' (relative transcript) expression levels. In addition, the fields ``gene\_mapping'' and ``time\_mapping'' includes information which is useful to match the genes with transcripts and the time points with data files, respectively. In order to load the data set, type: 
<<>>=
library("GPrank")
data(RNAseqDATA)
@
If one is interested in getting this data structure from raw BitSeq output files himself, he may use the \Robject{bitseq\_rnaSeqData} function:
%In this section, we explain how one can obtain a similar data structure with the sample data assuming s(he) has run BitSeq to estimate expression levels. Function
% to obtain this data structure from raw BitSeq output files and transcript information file. 
%
%\textbf{Transcript information file:}
%
%\begin{table}[h]
%%\centering
%\begin{tabular}{ccc}
%\hline
%\# example\_transcriptome\_file &   &  \\
%gene\_ID & transcript\_ID & transcript\_length \\	
%MGAT5 & MGAT5-001 & 8252 \\
%MGAT5 & MGAT5-201 & 2421 \\
%CHPF	 & CHPF-001 & 3013 \\
%CHPF & CHPF-201 & 2210 \\
%CHPF	 & CHPF-002	 & 1079 \\
%ARAP2 & ARAP2-001 & 7514 \\
%ARAP2 & ARAP2-005 & 396 \\
%ARAP2 & ARAP2-004 & 631 \\
%MLF1IP & MLF1IP-001 & 1998 \\
%MLF1IP & MLF1IP-003 & 1549 \\
%MLF1IP & MLF1IP-201 & 1014 \\
%MLF1IP & MLF1IP-004 & 688 \\
%\hline
%\end{tabular}
%\end{table}
%
%\textbf{Example BitSeq output file:}
%
%\# t0000.rpkmS-0 125 \\
%\# t0000.rpkmS-1 125 \\
%\# t0000.rpkmS-2 125 \\
%\# t0000.rpkmS-3 125 \\
%\# T (M rows,N cols) \\
%\# M 12 \\
%\# N 500 \\
%8.06307704816436	8.12999243630663	8.33963173293527	8.45627834800657	8.30603878539603	8.21234664731225	8.29653914972325 \ldots ..... \\
%\ldots \\
%\ldots \\
%
%Assuming BitSeq output files at different time points are named as t0000.rpkm, t0005.rpkm, t0010.rpkm, t0020.rpkm, t0040.rpkm, t0080.rpkm, t0160.rpkm, t0320.rpkm, t0640.rpkm, t1280.rpkm and 
%the transcript information file is named as ``example\_tr'', the following should be able to produce the data structure we have presented here.

<< eval=TRUE >>=
t=log(c(0,5,10,20,40,80,160,320,640,1280)+5) # One can apply
#transforation on time points
names(t)=c("t0000.rpkm","t0005.rpkm","t0010.rpkm","t0020.rpkm",
"t0040.rpkm","t0080.rpkm","t0160.rpkm","t0320.rpkm","t0640.rpkm",
"t1280.rpkm") # matches with the names of the BitSeq output files
trFileName="example_tr"
bitseq_sampleData=bitseq_rnaSeqData(t,trFileName)
@

\subsubsection{Fitting the models}
From now on, let us continue with the gene-level data although one can simply perform the same with \Robject{reltr} and \Robject{abstr} levels as well. The function \Robject{bitseq\_fitGPs} can be used to fit two GP models to each gene and compute the log Bayes factors:
<<>>=
gene_gpData=RNAseqDATA$gene
gene_GP_models=bitseq_fitGPs(gene_gpData)
@

If one is interested in saving the results into files, one should remember to specify the file names for \Robject{fileName\_logBF}, \Robject{fileName\_ModelParams}, \Robject{fileName\_NullModelParams} and input them as arguments in the \Robject{bitseq\_fitGPs} function:
<<eval=FALSE>>=
gene_GP_models=bitseq_fitGPs(gene_gpData, fileName_logBF,
fileName_ModelParams,fileName_NullModelParams)
@

\subsubsection{Visualizing the models}
\label{ex:bitseq}
Having the GP models fitted to the genes, one can plot the GP profile of a specified gene with the function \Robject{bitseq\_plotGP}. For example, the GP profile of the gene ARAP2 shown in Figure~\ref{fig:bitseq_gene} can be obtained by the following codes:
<<eval=FALSE, echo=TRUE>>=
item="ARAP2"
multi=0 # single GP plot in the figure
ylimits=NULL
x_ticks=NULL
x_label="log(5 + t/min)"
y_label="Expression level (log-rpkm)"
bitseq_plotGP(item, gene_GP_models, gene_gpData, multi, ylimits,
x_ticks, x_label, y_label)
@
\begin{figure}[h]
  \begin{center}
<<fig=TRUE, eval=TRUE, echo=FALSE>>=
item="ARAP2"
multi=0 # single GP plot in the figure
ylimits=NULL
x_ticks=NULL
x_label="log(5 + t/min)"
y_label="Expression level (log-rpkm)"
bitseq_plotGP(item, gene_GP_models, gene_gpData, multi, ylimits,
x_ticks, x_label, y_label)
@
\end{center}
\caption{Fitted GP model for the overall gene expression levels}
\label{fig:bitseq_gene}
\end{figure}

In order to save the figure, one can also specify the figure name in \Robject{plotName} option:
<<eval=FALSE, echo=TRUE>>=
bitseq_plotGP(item, gene_GP_models, gene_gpData, multi, ylimits,
x_ticks, x_label, y_label, plotName="ARAP2_gene.png")
@

The input \Robject{multi} determines whether multiple plots (=1) or only a single plot (=0) will be plotted on the same figure. For example, if we would like to plot the GP profiles of all the transcripts of ARAP2 gene, we can display all on the same plot by setting \Robject{multi} to 1. Let's try that for absolute transcript expression levels and produce Figure~\ref{fig:bitseq_abstr}:
<<eval=FALSE, echo=TRUE>>=
abstr_gpData=RNAseqDATA$abstr
abstr_GP_models=bitseq_fitGPs(abstr_gpData)
item="ARAP2"
multi=1
ylimits=NULL
x_ticks=NULL
x_label="log(5 + t/min)"
y_label="Expression level (log-rpkm)"
bitseq_plotGP(item, abstr_GP_models, abstr_gpData, multi, ylimits,
x_ticks, x_label, y_label)
@
\begin{figure}[h]
\begin{center}
<<eval=TRUE, fig=TRUE, echo=FALSE>>=
abstr_gpData=RNAseqDATA$abstr
abstr_GP_models=bitseq_fitGPs(abstr_gpData)
item="ARAP2"
multi=1
ylimits=NULL
x_ticks=NULL
x_label="log(5 + t/min)"
y_label="Expression level (log-rpkm)"
bitseq_plotGP(item, abstr_GP_models, abstr_gpData, multi, ylimits,
x_ticks, x_label, y_label)
@
\end{center}
\caption{Fitted GP model for the absolute transcript expression levels}
\label{fig:bitseq_abstr}
\end{figure}

Let us also do the same for relative transcript expression levels and obtain Figure~\ref{fig:bitseq_reltr}:
<<eval=FALSE, fig=FALSE, echo=TRUE>>=
reltr_gpData=RNAseqDATA$reltr
reltr_GP_models=bitseq_fitGPs(reltr_gpData)
item="ARAP2"
multi=1
ylimits=c(0,1) # ratio range between 0 and 1
x_ticks=NULL
x_label="log(5 + t/min)"
y_label="Relative expression level"
plotName="ARAP2_reltr.pdf"
bitseq_plotGP(item, reltr_GP_models, reltr_gpData, multi, ylimits,
x_ticks, x_label, y_label)
@
\begin{figure}[h]
\begin{center}
<<eval=TRUE, fig=TRUE, echo=FALSE>>=
reltr_gpData=RNAseqDATA$reltr
reltr_GP_models=bitseq_fitGPs(reltr_gpData)
item="ARAP2"
multi=1
ylimits=c(0,1) # ratio range between 0 and 1
x_ticks=NULL
x_label="log(5 + t/min)"
y_label="Relative expression level"
plotName="ARAP2_reltr.pdf"
bitseq_plotGP(item, reltr_GP_models, reltr_gpData, multi, ylimits,
x_ticks, x_label, y_label)
@
\end{center}
\caption{Fitted GP model for the relative transcript expression levels}
\label{fig:bitseq_reltr}
\end{figure}

\subsection{Quantitative analysis of population sequencing data}
In~\citep{Topa2015}, we developed a GP-based method BBGP --- beta
binomial Gaussian process --- for modeling the SNP frequencies in
fruit fly populations across several generations in an experimental
evolution study. The same method can in principle be used to analyse
any population sequencing data where one is interested in the
proportion of reads aligning to a specific location that contain a
specific feature (such as a SNP).

\subsubsection{Sample data}
Here we will use a small sample data set named \Robject{snpData}. This sample data set contains 5 replicates of counts and sequencing depth information for 5 SNPs at the generations (0, 10, 20, 30, 40, 50, 60).
In order to load the data set, run the command: 
<<>>=
data(snpData)
@

If one is interested in getting this data structure from raw sample files himself, he may use the \Robject{bbgp\_snpData} function:
<<>>=
dataFileName="sampleCountsData"
sampleSNPdata=bbgp_snpData(dataFileName)
@

\subsubsection{Fitting the models}
Given the counts and sequencing depth, we can use \Rfunction{get\_bbgpMeanStd} function in order to get the posterior means and standard deviations of the frequencies using a beta binomial model with parameters $\alpha$ and $\beta$ set to 1.
<<>>=
x=as.matrix(as.numeric(colnames(snpData$counts)))
# take the fifth SNP in the sample data as example:
counts=as.matrix(snpData$counts[5,]) 
seq_depth=as.matrix(snpData$seq_depth[5,])
bbgp=get_bbgpMeanStd(x,counts,seq_depth)
t=bbgp$time
y=bbgp$posteriorMean
v=(bbgp$posteriorStd)^2
@

Then, we can perform our GP-based test with \Rfunction{gpTest} function:
<<>>=
snp_gpTest=gpTest(t,y,v)
@

\subsubsection{Visualizing the models}
Once we have fitted the GP model, we can visualize it using \Rfunction{plotGP} function and obtain Figure~\ref{fig:bbgp}:
<<eval=FALSE, echo=TRUE>>=
model=snp_gpTest$model
ylims=c(0,1)
plotGP(model, ylimits=ylims)
title(xlab="Time", ylab="SNP frequency")
@
\begin{figure}[h]
\begin{center}
<<eval=TRUE, fig=TRUE, echo=FALSE>>=
model=snp_gpTest$model
ylims=c(0,1)
plotGP(model, ylimits=ylims)
title(xlab="Time", ylab="Frequency")
@
\end{center}
\caption{Fitted GP model of the SNP frequencies across generations}
\label{fig:bbgp}
\end{figure}

\section{Session info}
<< >>=
sessionInfo()
@

\small
\bibliographystyle{natbib}
\bibliography{GPrank_refs}

\end{document}
